1. 在JavaScript中，如何检查一个变量是否存在？如果变量未定义会发生什么？
 正确答案
 可以使用typeof操作符来检查一个变量是否存在，如果为定义，js会抛出一个referenceError。
2. 解释JavaScript中的全局变量和局部变量之间的区别。
全局变量位于全局作用域中，可以被任何其他作用域引用。局部变量仅在其所在的块作用域内有效，只能在它所在的作用域内被使用。
 全局变量可以在代码的任何地方被访问，而局部变量只能在声明它们的函数或作用域中被访问。
3. JavaScript对象是如何在内存中存储的？请解释。
javascript对象在内存中是以栈的形式保存。每一个object中存放的是引用对象的地址。
 正确答案
 js对象在内存中是以 ###堆###的形式存储的，对象存储在堆内存中，变量中存放的是对这些对象的引用。
4. 在JavaScript中，`Object.freeze()` 方法与 `Object.seal()` 方法有何不同？
不会
 Object.freeze()使对象完全不可修改，即不能添加新属性，也不能修改现有属性的值和配置，包括其不可写性、配置性和可枚举性。Object.seal()是对象不能添加新属性且不能删除属性，但已有属性的值如果是可写的，则可以修改
5. 什么是原型链？请解释其在JavaScript对象中的作用。
 原型链是js中实现继承的一种机制。每个对象都有一个原型对象，从原型对象继承方法和属性。对象方法和属性的查找，如果在当前对象中找不到，会沿着原型链向上查找，直到找到或达到原型链的顶端(通常是Object.protoType)
 例如，当你创建一个数组 [1, 2, 3]，这个数组继承自 Array.prototype，而 Array.prototype 又继承自 Object.prototype，最后 Object.prototype 的原型是 null。这就形成了一个从特定数组到 Object 的原型链。
6. 如何在JavaScript中复制一个对象？请提供不同方法的示例。
可以使用var obj2 = obj1复制一个对象，但这样的方法会和obj1共用同一个引用地址。
也可以使用字面量的方式写入和要复制对象一样的属性，这样的方法可以和复制对象分开使用不同的引用地址。
 正确答案
 var obj2 = {...obj1}是通过展开运算符创建obj1的浅拷贝；var obj3 = JSON.parse(JSON.stringfy(obj1))利用JSON方法深拷贝对象，但这种方法不能复制函数和循环引用。
 浅拷贝：仅复制对象的顶层属性，如果属性是引用类型，则复制的是引用而不是实际的对象。因此，原始对象和拷贝对象的引用类型属性将指向同一个对象。
 深拷贝：复制对象中的所有项，包括嵌套的对象。深拷贝生成的副本是完全独立的，原始对象的任何修改都不会影响到拷贝对象。
 函数：函数通常不被JSON方法（如 JSON.stringify() 和 JSON.parse()）处理，因为JSON只支持数据格式的序列化，函数不是数据格式。
 循环引用：当对象互相引用或自引用形成闭环时，JSON.stringify() 将无法处理这种结构，会抛出错误，因为它无法正确地序列化这种引用。
7. 描述JavaScript中的“this”关键字。它如何在不同的上下文中表现？
 this关键字指向函数调用的上下文(即调用函数的对象)。在全局执行上下文中，this指向全局对象(在浏览器中是window)；在对象方法中，this指向调用方法的对象；在严格模式下，没有明确上下文的函数中，this为undefined
8. 解释如何使用JavaScript创建和使用setter和getter函数。
 使用对象的get和set关键字可以定义getter和setter
```js
let obj = {
    get prop(){
        return this._prop;
    }
    set prop(value){
        this._prop = value;
    }
}
```
9. 什么是JavaScript中的垃圾回收机制？它是如何工作的？
垃圾回收机制指js会不定期地清除无法访问到的引用对象。
 正确答案：垃圾回收机制自动找到不再被使用的内存并释放。js使用标记-清楚算法，这种算法标记“可达”的对象，即从根(全局变量、活跃的局部变量等)开始访问到的对象，然后清除未被标记的对象
10. 如何防止JavaScript对象的属性被外部代码修改？
 Object.freeze()或Object.seal()可以防止对象被修改，还可以通过定义私有属性(使用闭包或者前缀#)来限制外部访问
